package application;

import java.util.Queue;

public class TaskGraph {

  private TaskGraphNode start;
  private TaskGraphNode end;

  public TaskGraph() {
    this.start = new TaskGraphNode();
    this.end   = new TaskGraphNode();
  }

  /**
   * It proceeds forward and recursively sets the degree of each
   * node to be the number of its incoming edges.
   *
   * @param node initially should be the TaskGraph's start node
   */
  private void setIncomingDegree(TaskGraphNode node) {
    //TODO Erik:
    //post: It sets the degree of each node to be equal to the number of
    // incoming edges of that node.
  }

  /**
   * It returns a queue of TaskGraphNodes whose FIFO ordering reflects the
     order in which the earliest completion time for the nodes has to be computed.
   */
  private Queue<TaskGraphNode> topologicalSort() {
    //TODO Erik:
    //post: It returns a queue of TaskGraphNode objects such that a node
    // added in the queue before another node indicates that there is a path
    // from the former node to the latter node in the task graph.
    return null;
  }

  /**
   * It computes the earliest completion time for each node in the order given
   * by the FIFO queue generated by the topological sort.
   */
  private void computeEarliestCompletionTime() {
    //TODO Naman:
    //post: Sets the earliest completion time for the start node to be zero. Sets the
    //      earliest completion time for each node, different from the start node, to be the
    //      maximum of the sum of the earliest completion time for its precedent node and the
    //      duration of the connecting edge, over all its precedent nodes.
  }

  /**
   * It computes the latest completion time for each node
   */
  private void computeLatestCompletionTime() {
    //TODO Naman:
    //post: Sets the latest completion time for each node.
  }

  public TaskGraphNode getStartNode() {
    return start;
  }

  public TaskGraphNode getEndNode() {
    return end;
  }
}
